### 思路
n 阶楼梯，从底向上考虑，由于每步步长不确定，所以谁能到 n，谁不能到 n，都是未知数。现已知终点，因此从终点往回推，推到 0 终止。n 往下时 n-1 和 n-2，所以问题变成了两个子问题：

* 1+（n-1）阶子问题
* 1+（n-2）阶子问题

而（n-1）阶子问题，又可以继续分两步向下为两个子问题：

* 1+（n-2）阶子问题
* 1+（n-3）阶子问题

树形结构不断向下分，结果会是 2^n 个子问题。但是存在大量`重复子问题`，为减少计算量，可用空间保存重复子问题的计算结果，下个重复子问题来临时不必再次计算，直接返回其结果即可，这便是`递归 + 记忆化搜索`。

再看原问题，递归本身会占用很多栈空间，有很多不必要的开销，可否不适用递归？当然可以！既然已经将重复子问题记录下来了，那么自底向上保存其值，不断开疆拓土，直到 n 就好了呀！这便是`Dynamic Programming`思想。

🌰：

* 初始化：memo[0] = 0; memo[1] = 1
* memo[2] = Max ( 1 + memo[1], 1 + memo[0] )，为什么是 2 项？因为只能分 2 步走，若可分 3 步，就得是 3 项比较。2 由下面的一个步骤上来，只能有两个选择：要么从 1 走一步到 2，要么从 0 走两步到 2。每一步都是如此
* memo[3] = Max ( 1 + memo[2], 1 + memo[1] )：从 2 走一步到 3、从 1 走两步到 3
* memo[4] = Max ( 1 + memo[3], 1 + memo[2] )：从3 走一步到 4、从 2 走两步到 4
* memo[n] = Max ( 1 + memo[n-1], 1 + memo[n-2])：从 n-1 走一步到 n、从 n-2 走两步到 n

如此把每一步的结果都分成一步骤一步骤上来，那么就只有 2 种结果，然后，一步步盖楼就好了。就像学习，每次学习一个步骤，可能跨小步，可能跨稍大步，不贪图一次跨多个步骤，那样地基不牢，memo[] 中可能没有下次需要的东西，反而打乱节奏。坚定的每次一步骤，或大或小，夯实基础，保持节奏，就是最好最快的方式。