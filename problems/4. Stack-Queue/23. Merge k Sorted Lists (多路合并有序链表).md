### é¢˜ç›®
[23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

### é¢˜ç›®æè¿°
```
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```

### æ€è·¯
**å †æ€æƒ³ï¼ŒPriorityQueueå®ç°**

**é€»è¾‘ï¼š**

æ¯æ¬¡ï¼Œå°†kä¸ªListçš„å¤´èŠ‚ç‚¹æ”¾å…¥å †ï¼Œåˆ©ç”¨å †è‡ªåŠ¨å–å‡ºæœ€å°å€¼ï¼ˆæœ€å°å †ï¼‰ã€‚ç„¶åï¼Œå°†å–å‡ºèŠ‚ç‚¹æ‰€åœ¨çš„é“¾è¡¨çš„ä¸‹ä¸€èŠ‚ç‚¹å…¥å †ï¼Œé‡å¤ã€‚

**ç»†èŠ‚ï¼š**

å¦‚ä½•æ‰¾åˆ°å–å‡ºèŠ‚ç‚¹çš„æ‰€åœ¨é“¾è¡¨ä¸‹ä¸€èŠ‚ç‚¹ï¼Ÿ  
é“¾è¡¨è‡ªèº«æœ‰nextï¼Œæ‰€ä»¥å–å‡ºnodeåï¼Œåªéœ€å°†node.nextå…¥å †å³å¯ã€‚

æƒ³è±¡ä¸€å¹…ç”»é¢ï¼Œå…¥å †çš„æ˜¯é“¾è¡¨å½“å‰å¤´èŠ‚ç‚¹ï¼Œè¡¨é¢ä¸Šçœ‹åªæ˜¯å¤´èŠ‚ç‚¹ï¼Œäº‹å®ä¸Šå…¶åéšè—ç€è¯¥é“¾è¡¨åç»­æ‰€æœ‰èŠ‚ç‚¹ï¼Œåƒä¸€ä¸ªé¾™å¤´ğŸ²ï¼Œåªä¸è¿‡æˆ‘ä»¬çš„æ­£è§†å›¾åªæœ‰è¯¥èŠ‚ç‚¹ä¸€ä¸ªç½¢äº†ï¼Œä¾§è§†å›¾çœ‹ğŸ‰ï¼Œå…¶å®åŒ…å«è¯¥èŠ‚ç‚¹åç»­æ‰€æœ‰èŠ‚ç‚¹ã€‚è¯¥èŠ‚ç‚¹æ—¢æ˜¯å•èŠ‚ç‚¹ï¼Œåˆä»£è¡¨æ•´ä¸ªé“¾è¡¨ï¼Œå…¶å€¼åœ¨valï¼Œä»£è¡¨è¯¥èŠ‚ç‚¹ï¼›nextï¼Œä»£è¡¨äº†é“¾è¡¨ä¸­çš„åç»­èŠ‚ç‚¹ã€‚

**ç‰¹æ®Šæƒ…å†µï¼š**

listsä¸­æœ‰ç©ºlistï¼Œæ¯æ¬¡å…¥å †å‰ï¼Œå…ˆåˆ¤ç©ºï¼Œä¿è¯å †ä¸­èŠ‚ç‚¹æ— nullã€‚

**å…·ä½“å®ç°ï¼š**

1. init, æ‰€æœ‰éç©ºlistå…¥å †ï¼›O(k log k)
2. è‹¥å †ä¸ä¸ºç©ºï¼Œå–å‡ºå †é¡¶å…ƒç´ ï¼Œå…¥ç»“æœé“¾ï¼›O(n log k)
3. å°†è¯¥èŠ‚ç‚¹çš„nextï¼Œåˆ¤ç©ºå…¥å †ã€‚

### å…³é”®ç‚¹åˆ†æ
* åˆ©ç”¨**å †**ï¼Œè€—æ—¶O(log k)ï¼Œæ¯æ¬¡ä»kä¸ªèŠ‚ç‚¹ä¸­å–å‡ºæœ€å°èŠ‚ç‚¹ï¼›å †çš„å…·ä½“å®ç°ï¼š **PriorityQueue**ï¼›
* å…¥å †çœ‹ä¼¼ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå› å…¶ä¸ºé“¾è¡¨ï¼Œæ‰€ä»¥å®åˆ™å…¶ğŸ²èƒŒåéšè—ç€åç»­æ‰€æœ‰èŠ‚ç‚¹ã€‚

### ä»£ç 
```java
package stack_and_queue;

import java.util.PriorityQueue;

public class _23_mergeKä¸ªList {
    public static class ListNode {
        int val;
        ListNode next = null;
        ListNode(int x){
            val = x;
        }

        // æ ¹æ®nä¸ªå…ƒç´ çš„æ•°ç»„arråˆ›å»ºä¸€ä¸ªé“¾è¡¨
        // ä½¿ç”¨arrä¸ºå‚æ•°ï¼Œåˆ›å»ºå¦å¤–ä¸€ä¸ªListNodeçš„æ„é€ å‡½æ•°
        public ListNode(int[] arr){

            if(arr == null || arr.length == 0)
                throw new IllegalArgumentException("arr can not be empty");

            this.val = arr[0];
            ListNode curNode = this;
            for(int i = 1 ; i < arr.length ; i ++){
                curNode.next = new ListNode(arr[i]);
                curNode = curNode.next;
            }
        }

        // è¿”å›ä»¥å½“å‰ListNodeä¸ºå¤´ç»“ç‚¹çš„é“¾è¡¨ä¿¡æ¯å­—ç¬¦ä¸²
        @Override
        public String toString(){

            StringBuilder s = new StringBuilder("");
            ListNode curNode = this;
            while(curNode != null){
                s.append(Integer.toString(curNode.val));
                s.append(" -> ");
                curNode = curNode.next;
            }
            s.append("NULL");
            return s.toString();
        }
    }


    public ListNode mergeKLists(ListNode[] lists) {
      ListNode dummy = new ListNode(-1);
      ListNode cur = dummy;
      PriorityQueue<ListNode> minHeap =
              new PriorityQueue<>((list1, list2) -> {
                  return list1.val - list2.val;//å¦‚æœlist1>list2ï¼Œåˆ™äº¤æ¢
              });
      if (lists.length == 0){
          return null;
      }
      for (ListNode list: lists){//O(k log k)
          if (list != null){
              minHeap.offer(list);
          }
      }
      //O(n log k)
      while (!minHeap.isEmpty()){//æœ‰æ•ˆèŠ‚ç‚¹ä¸ºdummyè‡³cur
          cur.next = minHeap.poll();
          cur = cur.next;
          if (cur.next != null){
              minHeap.offer(cur.next);
          }
      }
      return dummy.next;
    }

    public static void main(String[] args) {
        ListNode[] lists = new ListNode[3];
        //æ¯ä¸ªlistæ˜¯ä¸€ä¸ªListNode
        lists[0] = new ListNode(new int[]{1,4,5});
        lists[1] = new ListNode(new int[]{1,3,4});
        lists[2] = new ListNode(new int[]{2,6});
        System.out.println(new _23_mergeKä¸ªList().mergeKLists(lists));
        }
}
```


