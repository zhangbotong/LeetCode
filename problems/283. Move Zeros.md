### 题目地址

[283. Move Zeros](https://leetcode.com/problems/move-zeroes/)

### 题目描述
> Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.  
> Example:  
> Input: [0,1,0,3,12]  
> Output: [1,3,12,0,0]  
> Note:
> You must do this in-place without making a copy of the array.  
> Minimize the total number of operations.    

### 思路
两个指针k,i（Loop invariant）：  
[0,k)：不含0、原序子数组 ；  
[0,i]：遍历nums。 
![](https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181030085904.gif)

### 关键点
* 使用两个指针
* Loop Invariant

### 代码
```
class Solution {
    public void moveZeroes(int[] nums) {
        int k = 0;//nums中，[0,k)为原序非0元素
        for (int i = 0; i < nums.length; i++){
            if (nums[i] == 0){
                k = i;
                break;
            }
        }
        //遍历第i个元素后，保证[0，i]中非0元素都在[0,k)中
        //i = k:nums[k]不一定是0，[0,k),不能从k+1开始
        for (int i = k; i < nums.length; i++) {
            if (nums[i] != 0){
                //nums[k]不一定为0
                swap(nums, k, i);
                k++;
            }
        }
    }
    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = num[j];
        nums[j] = temp;
    }
}
```
### 总结
新学习**Loop Invariant**理念：  
声明变量时，明确变量的意义；  
书写整个逻辑时，维护住该意义。  
eg.  
[l, r), [l,r]  
本题中对k,i的声明即确定其意义：  
**[0,k)**为原序非0元素；  
遍历**[0，i]**；

