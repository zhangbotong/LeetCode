### 题目
[572. 后序+中序构建二叉树]https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal

限制：1. 1 <= inorder.length <= 3000；2. postorder.length == inorder.length；3. -3000 <= inorder[i], postorder[i] <= 3000；4. inorder 和 postorder 均无重复元素；5. inorder 和 postorder 均为有效数组

### 思路
1. 根据后序最后一个节点可以找到 root；
2. 再用 rootValue 去中序找到根节点位置，从而区分开中序的左子树、右子树；
3. 再用中序的左右子树的个数，去后序分割左右子树
4. 再递归 root.left = buildTree(inorderLeft, postorderLeft); root.right = buildTree(inorderRight, postorderRight);
### 关键点分析
1. **数组下标是相对于首元素的偏移。**
2. 先找root，后序最后一个元素是root。
3. 递归终止条件
   * 传进来中序、后序是空，返回 null；
   * 传进来中序、后序1个元素，返回该 node。选2仍需在递归前保证元素不空，因此如无例外，越底层（判空）的终止条件比上层（判1）好些。
### 代码
```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
        int length = inorder.length;
        // 终止条件
        if (length == 0) return null;
        // 单层递归逻辑
        int rootValue = postorder[length - 1];
        TreeNode root = new TreeNode(rootValue);
        // delimiter 是中序根节点下标，即左右子树分割点。后序也是
        int delimiter = 0;
        for (; delimiter < inorder.length && inorder[delimiter] != rootValue; delimiter++);
        // delimiter是偏移，去掉delimiter后，左子树长度刚好是delimiter
        int[] inorderLeft = new int[delimiter];
        // length - 1 是最后一个节点下标（相对于首节点偏移），再减去delimiter是(delimiter,length-1]个元素
        int[] inorderRight = new int[length - delimiter - 1];
        int[] postorderLeft = new int[inorderLeft.length];
        int[] postorderRight = new int[inorderRight.length];
        for (int i = 0; i < length; i++) {
            if (i < delimiter) {
                inorderLeft[i] = inorder[i];
                postorderLeft[i] = postorder[i];
            }
            // i 相对于 delimiter+1 的偏移
            if (i > delimiter) {
                inorderRight[i - delimiter - 1] = inorder[i];
                postorderRight[i - delimiter - 1] = postorder[i - 1];
            }
        }
        root.left = buildTree(inorderLeft, postorderLeft);
        root.right = buildTree(inorderRight, postorderRight);
        return root;
    }
```
