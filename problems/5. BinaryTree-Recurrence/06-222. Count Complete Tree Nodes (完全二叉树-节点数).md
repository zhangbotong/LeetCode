### 题目
[222. Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/)
### 题目描述
```
Given a complete binary tree, count the number of nodes.

Note:

Definition of a complete binary tree from Wikipedia:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

Example:

Input: 
    1
   / \
  2   3
 / \  /
4  5 6

Output: 6
```
### 思路
二叉树高度、深度：

![pic1](https://github.com/zhangbotong/LeetCode/blob/master/assets/222-树高.png)

![pic2](https://github.com/zhangbotong/LeetCode/blob/master/assets/222-完全二叉树.png)

> The depth of a node is the number of edges from the node to the tree's root node.
> A root node will have a depth of 0.
> 
> The height of a node is the number of edges on the longest path from the node to a leaf.
> A leaf node will have a height of 0
 
但是，这里的高度，并不是上述定义，而是上述定义+1，更符合直观感觉，这样满二叉树节点数=2^h - 1；

#### 思路1 -- 判断左右子树是否为满二叉树
**完全二叉树特点**：左右子树，一个为满二叉树，另一个为完全二叉树。只不过情况不同，子树高不同。若右子树高=左子树高=h，则左子树满h，右子树完全h，总结点数为2^hLeft -1 + countNodes(right)；否则，右子树高=左子树高-1.则右子树满h-1,左子树完全h，总结点数=2^右高 - 1 + countNodes(left)。

#### 思路2 -- 判断当前树是否为满二叉树
前提：cur一定是完全二叉树，可能满，可能不满。

如果cur为满二叉树，则count = 2^h - 1；

若cur不满，但其左右子树一定有一个是满的：

完全二叉树 4 种场景：

**图3，左满右不满（左右一定在同一层）：**
![image](https://github.com/zhangbotong/LeetCode/assets/7106986/9ba9d3f1-540f-443a-ab67-c6b5811e8479)
**图4，左不满右满（右一定比左低一层）：**
![image](https://github.com/zhangbotong/LeetCode/assets/7106986/69b5ca33-3bc5-4210-8815-7a6073b9f312)
**图5，左右都满，且左右在同一层（cur为满二叉树）：**
![image](https://github.com/zhangbotong/LeetCode/assets/7106986/0438b5c6-7c63-40ce-94da-5dd56ddb2955)
**图6，左右都满，且右比左低一层：**

![image](https://github.com/zhangbotong/LeetCode/assets/7106986/838def4b-8ffa-4439-af95-5db2f80db543)

对于满二叉子树，可以用 count = 2^h - 1 直接计算；对于不满但完全二叉子树，再递归其子树找满的；

判断是否满二叉树：
1. 沿左子树一直向左，计算左子树高度；沿右子树一直向右，计算右子树高度。若二者相等，则是满二叉树，不等则不是。
2. 分别计算左右子树的高度（分别沿左子树一直向左）
    * 若hLeft = hRight，则左子树一定满，右子树不一定；
    * 或hLeft > hRight，则右子树一定满，左子树不一定。
  
时间复杂度：O(log n * log n) < O(n)。
 
**逻辑**：

判断完全二叉树的两子树属于哪种情况，再分别“固定值+子问题”模式，递归求解。

递归逻辑一：左满右完全。则2^hLeft + 递归（right）；  
递归逻辑二：右满左完全。则2^hRight + 递归（left）；
递归终止：root == null。

### 关键点分析
* 完全二叉树特点：2子树，其一满二叉树，另一完全二叉树--天然递归结构；
* 递归逻辑、终止条件。

### 代码
```java
package 二叉树_递归;

public class _222_计算完全二叉树节点数 {
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    //本题认为，二叉树高 = 最长路径+1，所以，满二叉树节点数=2^h

    //计算完全二叉树的高，只需沿left不断深入就是最长路径
    private int height (TreeNode root){
        if (root == null){
            return 0;
        }
        return 1 + height(root.left);
    }

    /**
     * 判断左右子树是否为满二叉树：左右子树高度是否相等。
     *          若等，则左子树一定为满二叉树，再递归右子树；
     *          若不等，则右子树一定比左子树低，且右子树一定是满二叉树。
    */
    public int countNodes(TreeNode root) {
        if (root == null){
            return 0;
        }
        //使用node.left/right前，node需要先判非空
        int hLeft = height(root.left);
        int hRight = height(root.right);
        if(hLeft == hRight){//左满，对应图3、图5
            return (1 << hLeft) + countNodes(root.right);
        }
        //右满，图4、图6
        return (1 << hRight) + countNodes(root.left);
    }

    // 判断当前树是否为满二叉树：左子树最左节点高度与右子树最右节点高度是否相等。
    public int countNodes2 (TreeNode root) {
        if (root == null) return 0;
        // 判断当前树是否为满二叉树
        int lHeight = 1;// 根节点为第 1 层
        int rHeight = 1;
        TreeNode leftNode = root.left;
        TreeNode rightNode = root.right;
        while(leftNode != null) {
            leftNode = leftNode.left;
            lHeight++;
        }
        while(rightNode != null) {
            rightNode = rightNode.right;
            rHeight++;
        }
        if (lHeight == rHeight) {
            // 当前树一定为满二叉树，count = 2^h - 1
            return (1 << lHeight) - 1;
        }
        // 当前树一定不是满二叉树
        return countNodes2(root.left) + countNodes2(root.right) + 1;
    }

}
```
