## 二叉树与递归 总结
树是一种天然递归(子)结构（**缩小规模的子问题**），树的问题，很自然想到用递归解决。

所谓，递归，就是找到子问题与父问题的关系，通过关系将问题规模缩小但保留最终结构。

二叉树的问题，解题之前一定要想清楚是前中后序遍历还是层序遍历。大忌不想遍历顺序，稀里糊涂过。

#### 高度定义
<image width = '600' height ='500' src = "https://github.com/zhangbotong/LeetCode/assets/7106986/2eaf5baa-6a3e-4242-aadd-4cb59becc827"/>

|  类型 	| 定义  			|  基	|递归顺序		| 
|  ----	| ----  		| ----	| ----  		|
| 高度  	| 节点到叶的距离（叶高 1）	| 叶(1)	| 下 -> 上，因此后中，后序	|
| 深度  	| 节点到根的距离（根深 1） 	| 根(1)	| 上 -> 下，因此先中，先序	|

高度就是把叶子当基，逐层向上，因此要后中（左右中、右左中）即后序；深度是把根节点做基，逐层向下，因此要先中（中左右、中右左）即先序。

#### 二叉树节点分类：

1. 节点是否为空
	1. null节点；(node == null)
	2. 非null节点；（node != null）
2. 节点的孩子是否为空（节点保证非空）
	1. leaf；(node.left == null && node.right == null)
	2. 单孩子(node.left != null || node.right != null)
		1. 只有左孩子；(node.left != null)
		2. 只有右孩子; (node.right != null)
	3. 双孩子(node.left != null && node.right != null)

#### 后序遍历（BottomUp） VS 前序遍历（TopDown）

如：计算树中每个节点高度。因为root在top，所以直观理解，就从当前开始，逐步遍历完所有节点。但分析发现，这样底层节点的height会被多次计算。

**生活中不应只有先来后到，而应根据实际情况寻找更优方案**。也就是不考虑你从哪开始，只考虑怎样最优。本题显然BottomUp更优。BottomUp更优，但给的入口却是top，怎样解决？**所给与想用Invert--栈！！！**

#### 回溯
相关题目[113. Path Sum II](https://github.com/zhangbotong/LeetCode/blob/master/problems/5.%20BinaryTree-Recurrence/10-113.%20Path%20Sum%20II%20%EF%BC%88%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF%EF%BC%89.md)

回溯思想：不要害怕把当前节点纳入结果集，先假定其是结果的一部分，然后继续向下，若深入后发现假设错误，则移出结果集即可。

不能因为害怕他不对，就不敢把它纳入结果集，导致无法进行下去。勇敢的加进去，再验证，最后不行再退出来。若不把当前节点加进去，后续无法进行。先把它加进去，后面再验证。 若不符题，backtrack；符题，添加至结果集。


不要害怕尝试，错了及时改正。不要因为害怕出错而不往下进行、原地踏步。犯错和不敢尝试相比，更不好。

#### 终止条件：
所谓递归终止，就是其他问题的边界情况。目的是令递归逻辑中元素合法，终止条件就是边界，不合法元素。所以终止条件，就是递归逻辑中，再往下没有子结构了，即头尾的特殊情况。一般，递归逻辑中若用到left/right，终止条件得是root==null，否则，left/right不合法。

何时用root == null为终止?何时用leaf为终止？

1. 使用Stack、Queue时，为保证容器内不含null，用leaf终止
2. 否则，用root==null，更简洁

#### 缩小规模
递归，就是子问题与原问题有相同的结构，所以递归可以减小问题规模，直至递归终止。

递归--减治思想
